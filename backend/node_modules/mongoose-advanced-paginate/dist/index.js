"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ElementType: () => ElementType,
  SortOrderDirection: () => SortOrderDirection,
  filterTransform: () => filterTransform,
  isEmptyObject: () => isEmptyObject,
  paginatePlugin: () => paginatePlugin,
  searchTransform: () => searchTransform
});
module.exports = __toCommonJS(src_exports);

// src/types.ts
var ElementType = /* @__PURE__ */ ((ElementType2) => {
  ElementType2["ID"] = "id";
  ElementType2["STRING"] = "string";
  return ElementType2;
})(ElementType || {});
var SortOrderDirection = /* @__PURE__ */ ((SortOrderDirection2) => {
  SortOrderDirection2["ASC"] = "asc";
  SortOrderDirection2["DESC"] = "desc";
  return SortOrderDirection2;
})(SortOrderDirection || {});

// src/helper-functions.ts
var import_mongoose = require("mongoose");
var isMongoId = (str) => {
  return (0, import_mongoose.isValidObjectId)(str) && str.match(/^[0-9a-fA-F]{24}$/) && str.length === 24;
};
var filterTransform = (filterBy, selectors) => {
  const filters = [];
  filterBy.forEach((filterElem) => {
    const filterValue = selectors == null ? void 0 : selectors[filterElem];
    const filterObj = {};
    if (filterValue) {
      if (typeof filterValue === "string" && isMongoId(filterValue)) {
        filterObj[filterElem] = new import_mongoose.Types.ObjectId(filterValue);
      } else {
        filterObj[filterElem] = filterValue;
      }
    }
    if (filterObj[filterElem] !== void 0 && filterObj[filterElem] !== null && filterObj[filterElem] !== "" && filterValue !== "All")
      filters.push(filterObj);
  });
  return filters;
};
var searchTransform = (searchBy, searchText) => {
  return searchBy.map((searchElem) => {
    const searchObj = {};
    if (isMongoId(searchText)) {
      searchObj[searchElem] = new import_mongoose.Types.ObjectId(searchText);
    } else {
      searchObj[searchElem] = {
        $regex: searchText,
        $options: "i"
      };
    }
    return searchObj;
  });
};
var isEmptyObject = (obj) => {
  return obj === void 0 || Object.keys(obj).length === 0;
};

// src/plugin.ts
var paginatePlugin = (schema) => {
  schema.statics.paginate = function(query, options) {
    return __async(this, null, function* () {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
      const page = options.page || 1;
      const limit = options.limit;
      const filterPipeline = [];
      if (!isEmptyObject(query)) {
        filterPipeline.push({ $match: query });
      }
      options.customFilters && filterPipeline.push(...options.customFilters);
      if (((_b = (_a = options.filter) == null ? void 0 : _a.filterBy) == null ? void 0 : _b.length) && !isEmptyObject((_c = options.filter) == null ? void 0 : _c.selectors)) {
        const filters = filterTransform(
          (_d = options.filter) == null ? void 0 : _d.filterBy,
          (_e = options.filter) == null ? void 0 : _e.selectors
        );
        filters.length && filterPipeline.push({
          $match: {
            $and: filters
          }
        });
      }
      ((_g = (_f = options.search) == null ? void 0 : _f.searchBy) == null ? void 0 : _g.length) && ((_h = options.search) == null ? void 0 : _h.searchText) !== void 0 && ((_i = options.search) == null ? void 0 : _i.searchText) !== "" && filterPipeline.push({
        $match: {
          $or: searchTransform(
            (_j = options.search) == null ? void 0 : _j.searchBy,
            (_k = options.search) == null ? void 0 : _k.searchText
          )
        }
      });
      const countPipeline = [
        ...filterPipeline,
        { $count: "total" }
      ];
      const recordsPipeline = [...filterPipeline];
      options.lookups && recordsPipeline.push(...options.lookups);
      if ((_l = options.sortOrder) == null ? void 0 : _l.id) {
        recordsPipeline.push({
          $sort: {
            [(_m = options.sortOrder) == null ? void 0 : _m.id]: options.sortOrder.direction === "asc" /* ASC */ ? 1 : -1
          }
        });
      }
      options.extraStages && recordsPipeline.push(...options.extraStages);
      if (limit) {
        const skip = (page - 1) * limit;
        recordsPipeline.push({ $skip: skip });
        recordsPipeline.push({ $limit: limit });
      }
      options.project && recordsPipeline.push({ $project: options.project });
      const aggregationPipeline = [
        {
          $facet: {
            total: countPipeline,
            records: recordsPipeline
          }
        }
      ];
      const [aggregationResult] = yield this.aggregate(
        aggregationPipeline,
        options.aggregateOptions
      );
      const total = ((_n = aggregationResult == null ? void 0 : aggregationResult.total[0]) == null ? void 0 : _n.total) || 0;
      const records = (aggregationResult == null ? void 0 : aggregationResult.records) || [];
      return {
        total,
        page,
        limit,
        records
      };
    });
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ElementType,
  SortOrderDirection,
  filterTransform,
  isEmptyObject,
  paginatePlugin,
  searchTransform
});
